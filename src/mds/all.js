const info = {"articles":{"c313e9c3d7c99604055be4a01c9f9a96":{"title":"webgl学习日志（一）","category":"笔记","tags":["webgl","3D"],"date":["2022","5","17"],"name":"webgl学习日志（一）.md","con":"<p>由于某些不可抗力因素，从一周前开始学习webgl相关的知识，但期间作业一堆，还有两三天时间搞产品宣传视频到凌晨，于是学习进度也并不怎么样...</p>\n<p>webgl毕竟已经十年以上了，网上的资料、教程什么的也确实不少，但遇到跑不通的demo和奇奇怪怪的js依赖文件还是挺头疼的。到今天想想不如找本比较全面的书来看，熟悉了一些之后再看网上的代码比较好。</p>\n<p>这里先做一个阶段性的总结，主要分为几大块吧，但每一块到现在也就学了个皮毛。一是计算机图形学的基础，二是webgl的原理和基础操作方法，三是webgl上的交互和动画。至于其他已经封装好的库，稍微看了看，但没做重点，也就跑通了xeogl的本地展示demo。</p>\n<h1 id=\"计算机图形学基础\">计算机图形学基础</h1>\n<p>首先是计算机对三维物体的呈现问题，计算机只能通过像素显示栅格化之后的点、线、面，（实际上说全是面也可以，毕竟毕竟目前用webgl也不能保证支持改变线的粗细，想要画出不同粗细的线还是得用面来处理）。也就是说一个物体具体要怎么画还是得告诉电脑才行。</p>\n<p>一开始觉得绘制复杂物体本身会很难，但实际上原理层面也没有非常复杂，更加困难的还是在处理光学问题上，比如环境光、打光、阴影，或是说次表面、反射等等。</p>\n<p>首先是<strong>坐标系</strong>问题，webgl是一个(x,y,z)都<strong>在[-1,1]范围内的右手坐标系</strong>（一般使用的过程中），所以用一个三维向量来表示位置，用三个点一组表示一个面。（vec4中表示为x, y, z, w，其中最后的w默认取1，实际上对于webgl而言最后传入的vec4位置会转为x/w, y/w, z/w。）</p>\n<p>其次是变换矩阵，位移、旋转、缩放通过矩阵表示是相对方便而且高效率的方式，将它们按照<strong>正确的顺序相乘</strong>即可得到所谓的转换矩阵，用来表示物体的变换，当然也可以直接用来处理坐标系的转换，这一点及其重要。</p>\n<p>然后是具体的三维显示问题。首先要明确的一点是，我们的屏幕是二维的（废话），也就是说对于最终用于绘制的点的三维坐标而言，只有x, y是切切实实被用于确定屏幕上点的位置的，z和w并不能直接起作用，这两个值只有在处理透视和上色之前才能起到作用。</p>\n<p>关于三维显示的透视问题。如果是正交视图，即没有任何透视关系，那么不需要额外处理，否则还需要<strong>让x,y与z的大小相关</strong>，以满足近大远小的关系，这一部分也可以用上述的矩阵完成。如果考虑相机位置的话还需要另写一个矩阵，还需要考虑长宽比、视距等等，这些内容有很多相关的库可以帮助处理这些矩阵的建立、变换等。</p>\n<p>讲完了点还有面，面的绘制大概有以下几点。一是<strong>面全都是以三个点一组进行描述的</strong>，也就是说对于一个正方体，6个正方形面共12个三角形，每个三角形3个顶点，对于计算机而言需要当作36个顶点来处理。二是面分正反，三点顺序<strong>顺时针为反、逆时针为正</strong>，如果保证朝向外面的都是正三角形，那么可以减少面的绘制数量提升效率。（终于知道mc卡到方块里面为什么可以看到地下矿洞了，方块内部往外看都是反面压根就没渲染）三是遮挡关系需要使用z坐标处理，如果一个像素渲染时发现该位置有个z更大的已渲染像素，则直接跳过。</p>\n<p>之后就是打光和材质了，只是上贴图也就是改变一下面绘制时的颜色获取，但涉及到高光贴图、法线贴图、镜面效果、漫反射效果、次表面效果等等就比较麻烦了，打光方面点光、平行光、环境光、其他物体的反光，光晕、高亮，雾气、丁达尔效果等等每一个都有不同的算法，再考虑效果的叠加处理和性能的提升......（能做mme的都是大佬啊）</p>\n<h1 id=\"webgl部分\">WebGL部分</h1>\n<p>从理论到落地无论在什么工程领域都有着或大或小的鸿沟，从图形学到WebGL也不例外，原以为看懂原理就可以很快上手WebGL，是我天真了。</p>\n<p>WebGL最核心的部分就是它的渲染管线，如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220517-1.jpg\" alt=\"WebGL渲染管线\"></p>\n<p>这是整个webgl的核心内容，其中绿色的部分为我们可以操作的部分，深蓝色的两块是电脑自动进行操作的部分。简单来说就是，你先告诉电脑有哪些点，打算怎么组装（顶点着色器），之后电脑就会把这些点分好组，把每个要渲染的像素位置找到，再一个一个像素传到片元着色器中用颜色填充（片元/像素着色器）。</p>\n<h2 id=\"hello-world\">Hello World</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&lt;script&gt;\n    const canvas=document.getElementById(&#39;canvas&#39;);\n    const gl=canvas.getContext(&#39;webgl&#39;);\n    canvas.width=&quot;100&quot;;\n    canvas.height=&quot;100&quot;;\n    gl.clearColor(0,0,0,1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n&lt;/script&gt;\n</code></pre>\n<p>这就是最简单的webgl程序，首先在html中创建一块画布，这里需要用元素的长宽而非css的长宽来控制画布大小，然后用js获取画布后绑定webgl的上下文，用不透明纯黑清空画布。</p>\n<p>这里涉及到了webgl的<code>clearColor()</code>和<code>clear</code>接口，以及关键字<code>COLOR_BUFFER_BIT</code>。webgl中有巨多的接口和关键字，但为了能看懂上层封装的各类webgl库，这些还是有必要了解的...</p>\n<h2 id=\"基本操作\">基本操作</h2>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;利用索引绘制矩形&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;\n    &lt;script type=&quot;shader-source&quot; id=&quot;vertexShader&quot;&gt;\n        precision mediump float; //浮点数设置为中等精度\n        attribute vec2 a_Position; //接收 JavaScript 传递过来的点的坐标（X, Y）\n        attribute vec2 a_Screen_Size; // 接收canvas的尺寸。\n        attribute vec4 a_Color;\n        varying vec4 v_Color;\n        void main(){\n            vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0; // 将 canvas 的坐标值 转换为 [-1.0, 1.0]的范围\n            position = position * vec2(1.0, -1.0); // canvas的 Y 轴坐标方向和设备坐标系的相反\n            gl_Position = vec4(position, 0.0, 1.0); // 最终的顶点坐标\n            v_Color = a_Color; // 将顶点颜色传递给片元着色器\n        }\n    &lt;/script&gt;\n    &lt;script type=&quot;shader-source&quot; id=&quot;fragmentShader&quot;&gt;\n        precision mediump float; //浮点数设置为中等精度\n        varying vec4 v_Color; //全局变量，用来接收 JavaScript传递过来的颜色\n        void main(){\n            vec4 color = v_Color / vec4(255, 255, 255, 1); // 将颜色处理成 GLSL 允许的范围[0， 1]\n            gl_FragColor = color; //确定最终颜色\n        }\n    &lt;/script&gt;\n    &lt;script src=&quot;../utils/webgl-helper.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n    // 在helper里面对一些功能进行了简单封装，以下几个部分就是简单调用\n    let canvas = getCanvas(&#39;#canvas&#39;);\n    resizeCanvas(canvas);\n    let gl = getContext(canvas);\n    let program = createSimpleProgramFromScript(gl, &#39;vertexShader&#39;, &#39;fragmentShader&#39;);\n    gl.useProgram(program);\n\n    // 获取 canvas 尺寸\n    let a_Screen_Size = gl.getAttribLocation(program, &#39;a_Screen_Size&#39;);\n    // 将 canvas 尺寸传递给顶点着色器\n    gl.vertexAttrib2f(a_Screen_Size, canvas.width, canvas.height);\n\n    // 定义组成矩形的两个三角形，共计六个顶点，每个顶点包含2个坐标分量和4个颜色分量。\n    let positions = [\n        30, 30, 255, 0, 0, 1,//V0\n        30, 300, 0, 255, 0, 1, //V1\n        300, 300, 0, 255, 0, 1, //V2\n        300, 30, 0, 0, 255, 1//V3\n    ];\n\n    let a_Position = gl.getAttribLocation(program, &#39;a_Position&#39;);\n    let a_Color = gl.getAttribLocation(program, &#39;a_Color&#39;);\n\n    gl.enableVertexAttribArray(a_Position);\n    gl.enableVertexAttribArray(a_Color);\n    // 创建缓冲区\n    let buffer = gl.createBuffer();\n    // 绑定缓冲区为当前缓冲\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    // 设置 a_Position 属性从缓冲区读取数据方式\n    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 24, 0);\n    // 设置 a_Color 属性从缓冲区读取数据方式\n    gl.vertexAttribPointer(a_Color, 4, gl.FLOAT, false, 24, 8);\n    // 向缓冲区传递数据\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n    //定义绘制索引数组，012和023两个面组成正方形\n    //接下来将顶点信息写入缓冲区\n    let indices = [0, 1, 2, 0, 2, 3];\n    //创建索引缓冲区\n    let indicesBuffer = gl.createBuffer();\n    //绑定索引缓冲区\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n    //向索引缓冲区传递索引数据\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n\n    gl.clearColor(0, 0, 0, 1);\n\n    function render(gl) {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);\n    }\n    render(gl);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220518-1.jpg\" alt=\"绘制彩色正方形\"></p>\n<p>有一说一，这么一个简单的功能，只是确定了四个点的位置和颜色，然后组装成两个三角形，就得用到如此复杂的代码，而且渲染器那部分已经封装得很简单了，反正就挺离谱的...</p>\n<p>稍微讲讲原理，顶点着色器负责将js给出的canvas位置转化为[-1,1]的范围，并将顶点颜色赋给varying类型的变量用于给片元着色器调用。对于片元着色器而言，拿到了顶点的颜色后会自动插值范围内的其他非顶点，形成渐变效果（也就是说，在三点颜色一致时，这个面就是纯色）。</p>\n<p>至于如何做到用js将值传入顶点着色器，这就需要用js给顶点着色器定义的全局变量和属性变量进行赋值。这里有以下两种方法，一是获取变量的位置直接赋值，如上面的<code>a_Screen_Size</code>变量，还有一部分采用的是缓冲区，就是先建立一个特定的大数组，按顺序存好所有的数据，再存到如<code>ELEMENT_ARRAY_BUFFER</code>这种特定的缓冲区里面，再规定变量从缓冲区读入的方式，即可正常使用。</p>\n<p>不得不说，有太多内容都需要进一步封装才能较好使用...</p>\n<h2 id=\"交互和动画\">交互和动画</h2>\n<p>这部分代码全放上来太长了，只放部分反正也没法跑通，不如先讲讲思路。</p>\n<p>交互方面，实际上都是js基础的内容了，包括在画布上捕获鼠标事件，在特定条件下（如点击响应，拖拽响应等等）触发变量重新计算赋值，然后重新绘制界面。但与具体绘制的内容交互，如点击某一个部分等，一个简单的思路在于让不同的部分在点击那一个瞬间重绘成不同的纯色，根据颜色查表得到不同的部位，在下一个瞬间再绘制正常的颜色。而对于表示框这种会跟着某个部位运动的部位，可以取部位上的一个点，在js中直接对该点矩阵运算得出在画布上的位置，然后就可以建立一个悬浮的html元素始终跟随。</p>\n<p>动画的话，这块还没了解太多，包括后面的帧缓冲区之类的内容。这里讲讲已知的内容好了。首先是js的定时器函数<code>setInterval</code>是一个异步函数，并不能保证时间间隔，你设置了10ms的时间间隔，结果这个函数光排队都不止10ms也是有可能发生的...所以可以的话还是用新的<code>requestAnimationFrame</code>函数处理比较好，性能也会好一些，不会占用浏览器太多资源。然后就是动画实际上就是一帧一帧画内容而已，一般情况下整张画布重新画是最方便也是最常用的方法，当然如果画面变化不大，为了提升性能也可以只画有变化的地方。</p>\n<p>至于打光渲染什么的就没有过多了解了，只是知道个大概实现原理，等需要的时候再学也完全来得及（手上有本《WebGL编程指南》这种书方便多了，很多东西网上真的不太好找...）</p>\n<p>参考部分：\n<a href=\"https://zhuanlan.zhihu.com/p/438742595\">初识 WebGL ：渲染管线</a></p>\n","stat":{"dev":174849346,"mode":33206,"nlink":1,"uid":0,"gid":0,"rdev":0,"blksize":4096,"ino":17732923533225038,"size":12426,"blocks":32,"atimeMs":1653011012389.4656,"mtimeMs":1652855572050.0393,"ctimeMs":1652855572050.0393,"birthtimeMs":1652776767401.7295,"atime":"2022-05-20T01:43:32.389Z","mtime":"2022-05-18T06:32:52.050Z","ctime":"2022-05-18T06:32:52.050Z","birthtime":"2022-05-17T08:39:27.402Z"}},"024e62acf07507fed9471fd52ee4ec3d":{"title":"蒙特卡洛树","category":"笔记","tags":["AI","算法"],"date":["2022","4","8"],"name":"蒙特卡洛树.md","con":"<p>为了做AI课程的作业，需要用蒙特卡洛树的算法实现一个自动下棋的AI，然而无论是看书还是看课程PPT，或是网上的各类文章，还是觉得一知半解。于是也只好按照书上的框架先把代码给写完。结果是它只能保证打过随机函数，和初级难度对局好几局才能赢一次，更不用说其它难度了...（我严重怀疑是不是有些代码是不是压根就没跑起来，不过当时ddl将至也没时间细看了）</p>\n<p>虽然但是，这个算法的原理还是差不多弄明白了，顺手记录一下好了。</p>\n<p>首先是课件上给出的基本介绍，和网上查到的种种大同小异。</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220408-1.jpg\" alt=\"蒙特卡洛树基本结构\"></p>\n<p>总觉得这类介绍应该是比较清楚了，但还是不算直观，还是想讲讲自己的理解吧。</p>\n<p>首先，从概念上而言，蒙特卡洛树是希望通过对接下来每一个备选方案的结果随机采样的方式，评估下一步所有备选方案的优劣，也就意味着它会在规定步数或时间内不停采样、评估，知道外界告诉它停下。</p>\n<p>具体操作上，将当前节点设为根节点，下一步所有的备选方案为它的子节点。接下来进入循环，不停选择备选方案并进行所谓的<code>模拟</code>和<code>反向传播</code>。其中选择备选方案的原则是：优先探索未探索过的节点，若全都探索过，就选择<code>UCB1</code>值更高的节点。在被迫结束时，返回<code>UCB1</code>值最高的方案并返回。</p>\n<p>模拟的过程，就是根据被选中方案目前的状态随机继续进行直至结束，并返回结果。如果是下棋，即接下来从这个节点开始，两方都开始随机下棋，直到这句结束，并将结果（输、赢或平局）返回。</p>\n<p>而反向传播，则是通过被选中节点以及它这次模拟返回的结果，对它和它以上节点的状态进行更新，更新内容包括反向传播次数N、总模拟奖励Q。其中每次奖励ΔQ需要自己设定，比方说棋局胜利为+1，败北为-1，平局为0。至于为什么要记录这两个值，就要讲到MCTS最重要的<code>UCB1</code>了。</p>\n<p><code>UCB1</code>的作用是为每一个节点进行打分，分数更高的节点将会更倾向于被探索和最后被选中返回。该函数需要读入该节点的<code>N</code>、<code>Q</code>和父节点的<code>N_0</code>，以及权重<code>C</code>，这个函数将会返回以下结果：</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220408-2.jpg\" alt=\"\"></p>\n<p>其中<code>C</code>为权重，值越大越倾向于探索反向传播次数少的节点，可根据要求调整，我在作业中取值为根号二。在最终返回决策时调用UCB1计算时，一般将<code>C</code>置零。</p>\n<p>需要注意这里只迭代了第一层，这里实际上可以继续向下拓展备选方案层，这样在下次调用时可以继承这次计算过程的一部分结果从而增加采样总数。每次的奖励也可以自己设定，例如让AI认为平局也挺好，就可以把平局的奖励也设为+1，或+0.5等。</p>\n<p>这样就讲清楚了大致思路，但以上也只能算是我对MCTS算法的粗浅理解...若以后发现问题很大，在回来看看要不要改改...</p>\n","stat":{"dev":174849346,"mode":33206,"nlink":1,"uid":0,"gid":0,"rdev":0,"blksize":4096,"ino":4503599628974494,"size":3232,"blocks":8,"atimeMs":1653011012399.4355,"mtimeMs":1649385786560.369,"ctimeMs":1649385786560.369,"birthtimeMs":1649376864113.7039,"atime":"2022-05-20T01:43:32.399Z","mtime":"2022-04-08T02:43:06.560Z","ctime":"2022-04-08T02:43:06.560Z","birthtime":"2022-04-08T00:14:24.114Z"}},"f8ec37a6fce75aeea1c8359607a0d45e":{"title":"博客搭建小记","category":"随记","tags":["博客","react"],"date":["2022","4","5"],"name":"博客搭建小记.md","con":"<p>距离当时开始折腾hexo博客已经过去快一年了吧，这段时间的技术长进还是有些的，目前的博客搭建是使用react系列从零开始的产物。</p>\n<p>不使用hexo，最主要的原因有两点：一是想要学习学习react的使用，二是hexo内在逻辑和使用的方法还是有些学习门槛的，特别是自己制作theme还需要模板引擎，目前能把react学好就不错啦...</p>\n<p>先附上一张现在的博客截图吧：</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220504-1.jpeg\" alt=\"\"></p>\n<p>至于为什么会长成这样，实际上前期也没有什么非常严格的规划，无非是做一点调一点，毕竟不会的东西还太多，万一设计好了实现不出来也比较麻烦就是了...有些布局是借鉴了<a href=\"https://www.yunyoujun.cn/\">云游君</a>大佬的博客，例如左边的menu，但还是魔改了不少...要问为什么是这样的风格，主要是手里有些不错的图片不拿来用也挺可惜的，其他也没什么理由...</p>\n<p>为什么要做自己的博客？最一开始想的更多是能有个自己的小站好厉害，之后慢慢就变成了拿这个练手也还不错，毕竟也算是个人的一个小项目了...但实际上这个计划也是搁浅了大半年才重新拾起来的，真正重新搭建如今这个站点到现在也才过去了两个星期。</p>\n<p>关于背景图，这些图片是从一个我也忘了是哪里的api扒下来的，扒下来了有几百张，除去一小部分打不开的以外，挑了一些还算不错的图片推到github的仓库里面进行引用，进行背景轮播。</p>\n<h2 id=\"搭建过程\">搭建过程</h2>\n<p>第一步实际上是自动化脚本编写，想要解决将md文件转化为html格式，并且自动统计分类、标签、日期这些，将md中的图片推到github仓库，还有就是给每篇文章分配一个md5的字符串当主键...最后用powershell操作和调用js文件实现了如下操作：扫描所有$.md$文件，自动提取前几行$JavaScript$标签里面的内容，将后面的文本转为html字符串，生成一个巨大的js对象，每个key取哈希值，对应的value是一个包含日期、分类、标签、文本的对象。再新建一个js文件，里面的内容是让一个变量等于这个对象，再将这个对象导出，这样就可以被react直接调用了~</p>\n<p>先随便选了张图片当背景，开始制作上图所示的布局。然后发现css根基不牢，flex布局总是出各种问题，学习和改错的时间远大于设计的时间...还有就是寻找小图标的svg，由于没有经验也花了挺久的时间...</p>\n<p>稍微有了些布局，接下来就是交互设计。由于使用的是react，需要进行组件式开发以及router的配置，学习这些又是一座大山...只能说用到什么学什么。</p>\n<p>配好路由的下一步是分页面设计，也就是归档、分类和标签的具体页面设计，有一说一，这设计真不能说好看，但也就先凑合这用吧...主要问题还是在于吃了css基础不扎实的亏，不然效率能提高一倍（为什么不能更高？因为我的设计水平就到这了，想怎么布局也挺花时间啊...）</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220504-2.jpeg\" alt=\"\"></p>\n<p>然后是鼠标悬浮的动画响应，我的css3水平不太支持我搞这种东西啊...又是一顿猛学，才像那么点样子，但有些代码写烂了也不想回去改了...</p>\n<p>然后才是背景图片的切换，然后就吃了js基础不牢的亏。首先是react的useEffect不会用，其次是页面dom的style属性里有什么也不太懂，也是查了不少资料...（低情商：你怎么什么都不会？高情商：这个项目你能获得巨大的进步！）</p>\n<p>开始搞手机端适配，也就是左上角的那个小按钮，没有那个手机上就只能看到左边的menu了...这个也花了不少力气，包括摸索如何让页面style正确变化、找合适的元素重叠的上下关系、手机端menu自动收回等。由于事后发现手机上字太大，部分样式的大小用rem代替了px...</p>\n<p>然后是把书架和追番列表搞了搞，光是把那些番全部写进js里面就花了挺久，因为要写comment和找在线播放资源...</p>\n<p>由于周日上课，清明假期本来就只有昨天今天两天，由于昨天看了一天的番（86），现在是清明假期第二天傍晚了...也就是今天下午才把这些番全搞定，之后就过来写下这篇文章了...</p>\n<p>这是录入我看过所有番的js文件的截图，之后只会更长：</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/220504-3.jpg\" alt=\"\"></p>\n<h2 id=\"后记\">后记</h2>\n<p>这个博客搭建的过程我还是很有干劲的，毕竟比写作业、学枯燥的专业知识有趣多了，经常就是打开vscode就停不下来，除非迫不得已要写作业或是听课。</p>\n<p>也和身边的室友“炫耀”过我的博客，不过对于我来说花了很多精力的东西和别人看了觉得怎么样又有什么关系呢，只是虚荣心作祟罢了。</p>\n<p>现在整个博客算是搭完了，包括使用时可能会用到的自动化脚本，使用体验上来说和hexo没什么区别，只是敲的具体命令不一样而已。目前还没看到hexo生态特别吸引我的地方...</p>\n<p>希望以后能有时间多写写呢...</p>\n","stat":{"dev":174849346,"mode":33206,"nlink":1,"uid":0,"gid":0,"rdev":0,"blksize":4096,"ino":5348024559523809,"size":5281,"blocks":16,"atimeMs":1653011012399.4355,"mtimeMs":1649376831858.3655,"ctimeMs":1649376831858.3655,"birthtimeMs":1649146315120.026,"atime":"2022-05-20T01:43:32.399Z","mtime":"2022-04-08T00:13:51.858Z","ctime":"2022-04-08T00:13:51.858Z","birthtime":"2022-04-05T08:11:55.120Z"}},"8d2a4dcec2359288348de86310abdbad":{"title":"对hexo的尝试","category":"随记","tags":["hexo","博客"],"date":["2021","5","20"],"name":"对hexo的尝试.md","con":"<p>几经波折，总算是成功用hexo完成了blog的建立和部署，现在算是可以长舒一口气坐在这里写下第一篇文章了。</p>\n<p>先讲讲这里面的波折吧。</p>\n<p>从上个周日网上冲浪，浏览不少大佬的博客，被页面的精致和大佬们强大的技术水平折服之后，心里便萌生了创建一个属于自己的博客这样的想法。但转念一想，我还有微信小程序大赛的程序没写，C语言的团队大作业也才完成了一半 <del>话说为啥迄今为止三个人的团队只有我一个人在码呀</del>，哪有时间整这个。更何况整出个博客不是还要搞一个自己的域名和服务器才行，一个穷学生哪来的钱呐(哭)。</p>\n<p>但就这样什么都不做，又对不起这个想法，于是就先尝试性地搜搜有什么其他办法。</p>\n<p>功夫不负有心人，发现了GitHub提供有<code>github page</code>这个功能，虽然访问速度可能不太够，但至少将就着还能用了。</p>\n<p>于是跟着网上大佬的博客一步一步做，最后心情激动地在敲下<code>hexo server</code>后按下了回车，打开本地4000端口，果然看到了成功建立的标志 <del>忘记保存当时的截图了，从网上找了个一样的</del>:</p>\n<p><img src=\"https://raw.githubusercontent.com/chh0/blogPics/main/210520-1.jpeg\" alt=\"\"></p>\n<p>但是将它部署到<code>github page</code>上之后就发现了问题：github发邮件告诉我成功建立了个人主页，但貌似没法使用hexo自带的landscape主题... 也就是说我还得整个其他主题来用。</p>\n<p>好在给我抄答案的那个大佬的教程里面就安利了他自己的一套主题，就顺手拿来用了。然后... 连本地也加载不出来了，因为缺少插件。再仔细看了看教程，按照要求装好插件，本地算是可以正常跑起来了，和那个大佬博客开始的地方真就一模一样。</p>\n<p>再次尝试部署到<code>github page</code>上，发现还是加载不出来。哎，烦啊。在CSDN上又翻了不知道多少个文章，总算意识到github上面的路由和在本地配置的不一样导致css文件夹里面的东西没法加载。之后仔细研读了hexo官方文档中<code>_config</code>文件的配置，把路由改了改，重新部署。</p>\n<p>然后，发现GitHub上面的页面并没有什么变化。崩溃...</p>\n<p>上完了下午的C语言课，翘掉了微积分习题课，身体素质课中途溜走以后，在食堂用手机输入网址打开后，惊奇地发现居然部署成功了。<del>还是太年轻，原来<code>github page</code>上面的加载是有延时的呀</del> 有一说一，好久没这么开心过了。</p>\n<p>第二天，左看右看觉得这个主题虽然好看，但头像、链接什么的都还不太会配置，而且私货好像有点多，于是下定决心换个更适合的主题来用。</p>\n<p>先是在百度上搜了好久，发现一个人在知乎里面提到了很多包括next在内的theme，但使用过程中一方面有些部署到github上会莫名出错，另一些目录结构太复杂或是页面并不符合我的想法。也只好继续寻找新的theme。之后再hexo官网上发现原来有很多theme可以使用，又换了好几个，暂时先使用<code>hexo-theme-mls</code>这款主题，并且研究了一下里面的目录结构，打算接下来抽时间开发一个属于自己的主题。</p>\n<p>搞定了主题，就想给网页添加一个看板娘。好在这方面网上教程已经足够多了，实现一个并不是很难，只是功能不够完善罢了。先做出来，之后再说吧。</p>\n<p>至此，我的hexo制作博客已经完成了，之后只需要不断完善就可以啦！</p>\n","stat":{"dev":174849346,"mode":33206,"nlink":1,"uid":0,"gid":0,"rdev":0,"blksize":4096,"ino":33495522228674268,"size":3638,"blocks":8,"atimeMs":1653011012399.4355,"mtimeMs":1649150252603.587,"ctimeMs":1649150252603.587,"birthtimeMs":1648110032668.4136,"atime":"2022-05-20T01:43:32.399Z","mtime":"2022-04-05T09:17:32.604Z","ctime":"2022-04-05T09:17:32.604Z","birthtime":"2022-03-24T08:20:32.668Z"}}},"dateList":{"2021":{"1":[],"2":[],"3":[],"4":[],"5":["8d2a4dcec2359288348de86310abdbad"],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[]},"2022":{"1":[],"2":[],"3":[],"4":["024e62acf07507fed9471fd52ee4ec3d","f8ec37a6fce75aeea1c8359607a0d45e"],"5":["c313e9c3d7c99604055be4a01c9f9a96"],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[]}},"cateList":{"笔记":["c313e9c3d7c99604055be4a01c9f9a96","024e62acf07507fed9471fd52ee4ec3d"],"随记":["f8ec37a6fce75aeea1c8359607a0d45e","8d2a4dcec2359288348de86310abdbad"]},"tagList":{"webgl":["c313e9c3d7c99604055be4a01c9f9a96"],"3D":["c313e9c3d7c99604055be4a01c9f9a96"],"AI":["024e62acf07507fed9471fd52ee4ec3d"],"算法":["024e62acf07507fed9471fd52ee4ec3d"],"博客":["f8ec37a6fce75aeea1c8359607a0d45e","8d2a4dcec2359288348de86310abdbad"],"react":["f8ec37a6fce75aeea1c8359607a0d45e"],"hexo":["8d2a4dcec2359288348de86310abdbad"]}}
export default info